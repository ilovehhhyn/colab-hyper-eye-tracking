#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Optimized Dyadic Study Server (Computer A - IP: 100.1.1.10)
Low-latency version with UDP optimizations
"""

from psychopy import visual, core, event, data, gui
import socket
import json
import threading
import queue
import time
import struct

class OptimizedDyadUDPServer:
    def __init__(self, server_ip='100.1.1.10', client_ip='100.1.1.11', port=5555):
        """Initialize the optimized UDP server for dyadic communication"""
        self.server_ip = server_ip
        self.client_ip = client_ip
        self.port = port
        self.socket = None
        self.running = False
        self.message_queue = queue.Queue()
        
    def start_server(self):
        """Start the optimized UDP server"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        # UDP optimizations for low latency
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)  # Send buffer
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 65536)  # Receive buffer
        
        # Platform-specific optimizations
        try:
            # Linux/Unix: TCP_NODELAY equivalent for UDP
            self.socket.setsockopt(socket.IPPROTO_UDP, socket.UDP_CORK, 0)
        except (AttributeError, OSError):
            pass
        
        try:
            # Windows: disable Nagle's algorithm equivalent
            self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_DONTFRAG, 1)
        except (AttributeError, OSError):
            pass
        
        # Try binding to specific IP first, then fall back to 0.0.0.0
        try:
            self.socket.bind((self.server_ip, self.port))
            print(f"Bound to {self.server_ip}:{self.port}")
        except OSError as e:
            print(f"Could not bind to {self.server_ip}:{self.port}: {e}")
            print("Trying to bind to 0.0.0.0 (all interfaces)...")
            try:
                self.socket.bind(('0.0.0.0', self.port))
                print(f"Successfully bound to 0.0.0.0:{self.port}")
            except OSError as e2:
                print(f"Failed to bind: {e2}")
                raise
        
        # Reduced timeout for more responsive polling
        self.socket.settimeout(0.01)  # 10ms timeout instead of 100ms
        
        self.running = True
        print(f"Optimized UDP Server started on {self.server_ip}:{self.port}")
        print(f"Will communicate with client at {self.client_ip}:{self.port}")
        
        # Start high-priority receiving thread
        self.receive_thread = threading.Thread(target=self._receive_messages)
        self.receive_thread.daemon = True
        self.receive_thread.start()
        
        # Send initial ping to client
        self.send_message('ping', {'server_ready': True})
        
    def send_message(self, message_type, data=None):
        """Send a UDP message to the client with high precision timing"""
        if not self.socket:
            return False
            
        # Use high-precision timestamp
        timestamp = time.perf_counter()
        
        message = {
            'type': message_type,
            'timestamp': timestamp,
            'data': data
        }
        
        try:
            # Use compact JSON encoding
            message_json = json.dumps(message, separators=(',', ':'))
            message_bytes = message_json.encode('utf-8')
            
            # Send immediately without buffering
            self.socket.sendto(message_bytes, (self.client_ip, self.port))
            return True
        except Exception as e:
            print(f"Error sending message: {e}")
            return False
            
    def _receive_messages(self):
        """Receive UDP messages from client with minimal processing delay"""
        while self.running:
            try:
                data, addr = self.socket.recvfrom(1024)  # Smaller buffer for faster processing
                
                # Immediate timestamp upon receipt
                receipt_time = time.perf_counter()
                
                message = json.loads(data.decode('utf-8'))
                message['sender_addr'] = addr
                message['receipt_time'] = receipt_time
                
                # Calculate network latency (one-way trip time)
                if 'timestamp' in message:
                    network_latency = (receipt_time - message['timestamp']) * 1000
                    message['network_latency'] = network_latency
                
                self.message_queue.put(message)
                
            except socket.timeout:
                continue
            except Exception as e:
                if self.running:
                    print(f"Error receiving message: {e}")
                    
    def get_message(self, timeout=0):
        """Get a message from the queue"""
        try:
            return self.message_queue.get(timeout=timeout)
        except queue.Empty:
            return None
            
    def wait_for_response(self, expected_type, timeout=5):
        """Wait for a specific type of response from client"""
        start_time = time.perf_counter()
        while time.perf_counter() - start_time < timeout:
            message = self.get_message(timeout=0.001)  # Very short timeout
            if message and message.get('type') == expected_type:
                return message
        return None
        
    def precise_sync_send(self, message_type, data=None):
        """Send message with precise timing for synchronization"""
        # Pre-serialize message
        timestamp = time.perf_counter()
        message = {
            'type': message_type,
            'timestamp': timestamp,
            'data': data
        }
        message_bytes = json.dumps(message, separators=(',', ':')).encode('utf-8')
        
        # Send at precise moment
        self.socket.sendto(message_bytes, (self.client_ip, self.port))
        return timestamp
        
    def close(self):
        """Close the server"""
        self.running = False
        if self.receive_thread:
            self.receive_thread.join(timeout=1)
        if self.socket:
            self.socket.close()

# Main experiment code with timing optimizations
def run_experiment():
    """Run the server-side experiment on Computer A with optimizations"""
    
    # Get participant info
    exp_info = {
        'participant_A_id': '',
        'session': '001',
        'server_ip': '100.1.1.10',
        'client_ip': '100.1.1.11'
    }
    
    dlg = gui.DlgFromDict(dictionary=exp_info, 
                          title='Dyadic Study - Computer A (Server) - Optimized',
                          order=['participant_A_id', 'session'])
    if not dlg.OK:
        core.quit()
    
    # Initialize optimized UDP server
    server = OptimizedDyadUDPServer(
        server_ip=exp_info['server_ip'],
        client_ip=exp_info['client_ip'],
        port=5555
    )
    
    # Create window with optimizations
    win = visual.Window(
        size=[800, 600],
        fullscr=False,
        screen=0,
        winType='pyglet',
        allowGUI=True,
        color=[0, 0, 0],
        units='height',
        waitBlanking=False,  # Disable VSync for lower latency
        useFBO=False  # Disable framebuffer for faster rendering
    )
    
    # Create stimuli
    instructions = visual.TextStim(win, 
        text="Starting optimized UDP server...",
        height=0.05)
    
    trial_text = visual.TextStim(win,
        text="",
        height=0.1)
    
    sync_dot = visual.Circle(win,
        radius=0.05,
        fillColor='green',
        pos=(0.4, 0.4))
    
    status_text = visual.TextStim(win,
        text="",
        height=0.03,
        pos=(0, -0.4))
    
    latency_text = visual.TextStim(win,
        text="",
        height=0.03,
        pos=(0, -0.3),
        color='yellow')
    
    # Start server
    instructions.draw()
    win.flip()
    server.start_server()
    
    # Connection establishment with latency measurement
    instructions.text = "Waiting for Computer B to connect..."
    instructions.draw()
    win.flip()
    
    client_ready = False
    timeout_clock = core.Clock()
    last_ping = 0
    ping_times = []
    
    while not client_ready and timeout_clock.getTime() < 60:
        # Send ping every 100ms for better responsiveness
        if time.perf_counter() - last_ping > 0.1:
            ping_time = server.precise_sync_send('ping', {'server_ready': True})
            last_ping = ping_time
        
        instructions.text = f"Waiting for Computer B... ({60 - int(timeout_clock.getTime())}s)\nSending pings to {exp_info['client_ip']}"
        instructions.draw()
        win.flip()
        
        # Check for client messages
        message = server.get_message(timeout=0.001)
        if message and message.get('type') == 'pong':
            client_ready = True
            # Calculate round-trip time correctly
            if 'network_latency' in message:
                one_way_latency = message['network_latency']
                ping_times.append(one_way_latency)
                print(f"One-way latency: {one_way_latency:.2f}ms")
    
    if not client_ready:
        instructions.text = "Connection timeout. Please check network settings."
        instructions.draw()
        win.flip()
        core.wait(3)
        server.close()
        win.close()
        core.quit()
    
    # Calculate average latency
    avg_latency = sum(ping_times) / len(ping_times) if ping_times else 0
    
    # Connection established
    instructions.text = f"Computer B connected!\nAverage latency: {avg_latency:.2f}ms\nPress SPACE to start experiment"
    instructions.draw()
    win.flip()
    
    # Wait for experimenter to start
    event.waitKeys(keyList=['space'])
    
    # Send start signal with precise timing
    start_time = server.precise_sync_send('start_experiment', {
        'n_trials': 10,
        'sync_time': time.perf_counter()
    })
    
    # Wait for acknowledgment
    ack = server.wait_for_response('ack_start', timeout=3)
    if not ack:
        print("Warning: No acknowledgment from client")
    
    # Run trials with precise timing
    n_trials = 10
    trial_clock = core.Clock()
    data_log = []
    
    for trial_num in range(n_trials):
        # Pre-draw trial stimuli for faster display
        trial_text.text = f"Trial {trial_num + 1}"
        
        # Send trial sync signal with precise timing
        trial_sync_time = server.precise_sync_send('trial_sync', {
            'trial_number': trial_num + 1,
            'sync_timestamp': time.perf_counter()
        })
        
        # Wait for client sync acknowledgment
        sync_ack = server.wait_for_response('sync_ack', timeout=0.5)
        
        # Calculate sync latency correctly
        sync_latency = None
        if sync_ack and 'network_latency' in sync_ack:
            sync_latency = sync_ack['network_latency']
        elif sync_ack:
            # Fallback calculation if network_latency not available
            sync_latency = (sync_ack['timestamp'] - trial_sync_time) * 1000
        
        # Reset trial clock after sync
        trial_clock.reset()
        
        # Display trial immediately
        trial_text.draw()
        sync_dot.draw()
        
        # Show sync status
        if sync_ack:
            status_text.text = f"Sync OK"
            latency_text.text = f"Latency: {sync_latency:.1f}ms" if sync_latency else "Latency: N/A"
        else:
            status_text.text = "Sync warning"
            latency_text.text = "Latency: TIMEOUT"
        
        status_text.draw()
        latency_text.draw()
        win.flip()
        
        # Collect response with high precision timing
        response_start = time.perf_counter()
        keys = event.waitKeys(maxWait=3.0, keyList=['left', 'right', 'escape'], 
                            timeStamped=trial_clock)
        
        response = None
        rt = None
        
        if keys:
            response, rt = keys[0]
            if response == 'escape':
                break
                
            # Send response to client immediately
            server.send_message('server_response', {
                'response': response,
                'rt': rt,
                'precise_rt': time.perf_counter() - response_start
            })
        
        # Wait for client response
        client_resp = server.wait_for_response('client_response', timeout=3)
        
        # Log trial data
        trial_log = {
            'trial': trial_num + 1,
            'sync_time': trial_sync_time,
            'server_response': response,
            'server_rt': rt,
            'client_response': client_resp['data']['response'] if client_resp else None,
            'client_rt': client_resp['data']['rt'] if client_resp else None,
            'sync_latency': sync_latency,
            'avg_connection_latency': avg_latency
        }
        data_log.append(trial_log)
        
        # Brief ITI
        win.flip()
        core.wait(0.1)  # Reduced ITI for faster trials
    
    # End experiment
    server.send_message('end_experiment')
    
    # Save data
    import pandas as pd
    df = pd.DataFrame(data_log)
    filename = f'dyad_optimized_computerA_{exp_info["participant_A_id"]}_{time.strftime("%Y%m%d_%H%M%S")}.csv'
    df.to_csv(filename, index=False)
    
    # Show latency statistics
    latencies = [log['sync_latency'] for log in data_log if log['sync_latency'] is not None]
    if latencies:
        min_lat = min(latencies)
        max_lat = max(latencies)
        avg_lat = sum(latencies) / len(latencies)
        
        instructions.text = f"Experiment complete!\nLatency Stats:\nMin: {min_lat:.1f}ms\nMax: {max_lat:.1f}ms\nAvg: {avg_lat:.1f}ms\nData saved to {filename}"
    else:
        instructions.text = f"Experiment complete!\nData saved to {filename}"
    
    instructions.draw()
    win.flip()
    core.wait(5)
    
    # Cleanup
    server.close()
    win.close()
    core.quit()

if __name__ == '__main__':
    run_experiment()
